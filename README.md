# CyberThreatMap

Preface:
Network visualization is an ideal tool for communicating a large amount of data to a user, in a way which highlights the main concept of the data and its context. The best weapon in the battle against cyber attackers and potential online criminals is data. And while cybersecurity is a paramount concern amongst all organizations from enterprises to individuals, many existing tools for generating real time alerts lack a way to visualize this data. In some cases, the vast amount of data may seem uninterpretable. By visualizing the key-lines between communications, the network we are monitoring can be viewed on a map. With real time updates to the user interface, a data map can allow for easy filtering of incoming data. For example, showing only attacks which are perceived to have a large threat level. Understanding the location of incoming attacks, as-well as the time can help a user see patterns/trends in the data.

Map visualization can be particularly efficient at spotting DDoS (distributed denial of service) and DoS attacks, as the attacks are typically accomplished by flooding a targeted machine or server with an unmanageable amount of requests in order to disrupt the hosts connection to the internet. A analyst viewing the live data map would be able to identify the influx of messages from a single user, or group of users, in the case of a distributed attack

Machine One - Kafka & Py2Map

In this implementation, machine one is tasked with handling the incoming stream of IP addresses, and generating the geolocation information to be stored, and used for display purposes. This python file uses the following libraries: socket, geoIp, CSV, JSON, time and date-time.

A kafka server alows for a producer consumer implimentation.  The file producer.py, can be used to test the entire system.  It reads from a list of ip addresses and sends an id and bytecount to the kafka server on a topic called "ips".

Given an IP address, we start by finding the geo-data. Using a free MAXMIND database, GEOLITE2 city, the latitude, longitude, country, country code, city, and city can be found. The date of the attack is found and added to the JSON object.
In order for this json object to be sent to the server on virtual machine it must be converted to a string, and then encoded to bytes. The python file establishes a connection with the node JS server each time a new attack and its data is ready to be transferred.

Using the python socket library, a connection is established, and the message is sent. Before closing the connection, the module waits for a confirmation message from the server, confirming that the new attack has been received.

Machine Two - Threat Map & Node JS Server & MongoDB

Machine two is where everything involving the display of the map is handled. A node JS server acts as the web host and handles incoming messages containing data on new attacks. A MongoDB database is used to store all of the past threats, this history is needed for the display of further data. The map is implemented as a web application using javascript.
Many node JS modules are needed for system to run, such as express, http, socket.io, D3, dgram, net, fs and mongodb. All the necessary modules are located in the node_modules folder. The server receives messages in two ways, from incoming connections made by python files, like the one in machine one, and messages received over net-cat. The steps for processing the messages are the same, regardless of what method they are received. The raw message containing a new attack must first be decoded be decoded. Using a regex expression for each parameter of the attack data (longitude, city ect...), a match from the raw data is found for each, and a string type variable is found representing the raw data. A json object is constructed from the these string variables which can then be distributed to the map, and mongodb. The “send” function in the server first emits the message to the web server, then adds the new attack to the collection in the database. It finishes by calling a 2 functions which query the database in order to obtain data to be used in the display panels bellow the map interface and the counter for the number of attacks for the day. By obtaining data from the database each time the panels are updated, we ensure that the display panels are consistent with the number of attacks that have occurred, as attacks which did not occur while the map interface was open, are still accounted for. One aggregate
   
 query finds the total count for attacks which occurred with todays date. Two similar aggregate queries find the top five most occurring IP addresses, and top 5 most common countries. In order to find the number of attacks which occurred each day for the past week, seven separate aggregate queries were used, one for each of the past seven days. After each of these sets of queries is completed, a separate IO emit sends the data to the map.
The MongoDB, where a log of all attacks is stored is made of a single DB named “HonoursProjectThreatMap” and a collection called threats. Each document in threats holds all of the same data which was generated from the python file in machine one. For future implementations of this map, the new mongoDB atlas cloud storage could be used, as this way each user would not need to set up the collections locally, on their hard-drives.
The web application which serves as the maps interface is dependent on many javascript libraries: allfont, d3, d3 geoprojection, d3 topojson, datamaps, jquery, socket, and canvasjs. The data map is displayed in the centre of the screen, with four collapsable panels which can be extended from the bottom. This design allows for the panels to fully open, but not block the view of majority of the data map. The data map is implemented using D3’s equirectangular projection, as this projection best fit the background display map. In order to allow the background display to show, the fill of the data map was set to have an opacity of 0.01. This allowed for the borders of each country to still be displayed, and allowed for the D3 function which displays the country name when the mouse is hovered over. This feature was not available if the fill was simply set to None.
Each attack is displayed in a coloured ache with a bloom at the site of the IP (as precise as our data allows us to be). The colour of the arch is dependant on the size of the attack. With larger attacks being labeled as red, medium attacks as yellow, and relatively small attacks as green. When the mouse hovers above an existing bloom, location information will appear, as it can be
 
hard to judge the location of the attacks which come from close to the border of a country, or for when the user may not know the name of the country which the attack is coming from.
The first three panels (from left to right) display information which was obtained through a query by the server. Each panels has a separate socket function which listens for messages which carry potential updates to information. The most occurring IP address panel displays the IP of the attacker, and the number of times they have attacked the network. The top country panel displays the countries which the most attacks have been made from. The third panel displays a line graph, displaying the number of attacks per day which occurred over the past week. This can be useful for visualizing trends for which days of the week generate more malicious traffic than others.
The panel in the bottom right corner displays the information of a new attack, and is updated as new attacks are processed. The size of the attack as-well as the most specific location information available can be found here, along with the IP address of each attack.


